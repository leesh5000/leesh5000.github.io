---
title: 객체지향적인 코드 짜기
date: 2024-07-20 18:36:00 +09:00
categories: [Programming]
tags: [Programming]
---

> 이 문서는 작성자의 **개인적인 의견** 을 담고 있으며 절대적인 정답은 없음을 미리 알려드립니다.
{: .prompt-tip}

## Naming
---

**변수명은 줄여쓰지 않는다.**

> 짧고 예매한 변수명 보다는 차라리 길고 명확한 변수명이 낫다.

### 예시

- msg (x) -> message (o)
- num (x) -> number (o)
- cnt (x) -> count (o)

### 근거

Spring 프로젝트의 [RequestMatcherDelegatingAuthenticationManagerResolver 클래스](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/RequestMatcherDelegatingAuthenticationManagerResolver.html) 참고

## 축약어
---

축약어는 일반명사와 동일하게 취급하여 변수명을 지정한다.

### 근거

축약어를 모두 대문자로 작성할 경우, 다른 단어와 합성될 때 가독성을 해칠 수 있다.

- restApi (o) / RESTAPI (x)
- ApiClient (o) / APIClient (x)
- OidcId (o) / OIDCID (x)

### 예시

- ID : userID -> userId
- URL : userURL -> userUrl
- DTO : userDTO -> userDto
- REST : userREST -> userRest

## 주관적인 의미가 담김 단어 사용 지양
---

가급적 유의미하고 추상적인 단어 사용을 지양하고, 구체적인 단어를 사용

### 근거

Simple, Light, Complicated, Base 등과 같은 단어는 작성자의 주관적인 해석이 담겨있으므로 타인이 보았을 때는 그 해석을 달리할 수도 있다.

### 예시

- SimpleData (x)
- LightApplication (x)
- Complicated (x)

## Util 클래스 사용 지양
---

Util 이라는 이름의 클래스를 작성하지 말고, 역할을 명확히 하는 클래스 명으로 작성한다.

### 근거

Util 클래스는 객체지향 프로그래밍의 원칙 중 하나인 **단일 책임 원칙** 을 위반한다. 또한, Util 클래스라는 이름 하에 모든 static 메소드가 작성된다.

### 예시

```java
// bad
class AppilcationUtil {
    public static Application create() {
        return new Application();
    }
}

// good
class ApplicationFactory {
    public static Application create() {
        return new Application();
    }
}
```

## get vs find
---

get 메소드는 관례상 항상 인스턴스를 반환 받을 것을 기대하며 사용한다. (인스턴스가 없는 경우 예외 발생) find 메소드는 인스턴스를 찾지 못한 경우 null을 반환한다. 둘은 엄연히 다르기 때문에 구분해서 사용한다.

### 근거

- [Spring Data JPA 프로젝트의 getById, findById 메소드 참고](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html)

## isExist vs exist
---

isExist 동사를 반복하는 잘못된 단어이므로, exist로 표현한다.

## get
---

get을 남발하지 않는다. 

### 근거

get은 어떤 인스턴스의 상태 값을 가져오는 의미를 가지기 때문에 용도에 맞게 사용한다.

### 예시

- 메서드 명에서 getSumPrice (x) -> sumPrice (o)

## 디미터 법칙 (Law of Demeter)
---

디미터 법칙은 최소한의 지식 원칙(Principle of Least Knowledge)으로도 불리며, 다른 객체는 자신이 조작하는 객체의 속사정을 몰라야 한다는 것을 의미한다.

> TDA 원칙 (Tell, Don't Ask) : 객체에게 무엇을 해야 하는지 말하고, 객체가 알아서 처리하게 한다.

### 근거

-  [참고링크](https://mangkyu.tistory.com/147)

### 예시

```java
// bad - 수동적인 객체
@Getter @Setter
class User {
    private boolean active;
    private long lastLoginTimestamp;
}

class UserManager {
    public void doSomething(User user) {
        user.setActive(false);
        user.setLastLoginTimestamp(System.currentTimeMillis());
    }
}

// good - 능동적인 객체
class User {
    enum Status {ACTIVE, INACTIVE}
    private Status status;
    private long lastLoginTimestamp;

    public void inactive() {
        this.status = Status.INACTIVE;
    }

    public void login(Clock clock) {
        this.lastLoginTimestamp = clock.millis();
    }
}

class UserManager {
    public void doSomething(User user) {
        user.inactive();
        user.login(Clock.systemDefaultZone());
    }
}
```

## 주석
---

주석은 필요할 때만 사용한다. 만약 개발하다가 주석을 달고 싶은 느낌이 들면 그것은 **매서드를 분리하라는 신호**이므로 귀 기울여야 한다.

## Optional
---

NPE를 방지하기 위해 Optional을 자주 사용한다. 단, Optional을 매개변수로 받지 말고, 반환값으로 사용한다.

## Collection.Map을 남발하지 않는다.
---

Map은 너무 유용한 나머지 원래는 클래스로 분리되어야 할 것들을 분리하지않고 Map으로 사용하는 경우가 있다. Map을 사용하면 본인만 이해하는 코드가 될 확률이 높으므로 **가급적 사용을 지양하며, 불가피한 경우에는 일급 컬렉션으로 만들어 사용하며 scope 범위를 넘어가서는 안된다.**

### 근거

`Map<Long, Map<A, B>>`와 같은 코드는 명백한 안티 패턴이다. 그 이유는 [해당 링크](https://velog.io/@sorious77/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%93%9C-8.-%EA%B2%BD%EA%B3%84)를 참고한다.

## 일급 컬렉션을 사용하라

컬렉션을 직접 노출하지말고, 비즈니스에 종속적인 자료구조를 직접 만들어 사용한다.

[해당 링크 참고](https://jojoldu.tistory.com/412)

## 읽어볼만한 자료
---

- 구글 코드 스타일 가이드
